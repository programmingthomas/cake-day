//
//  Cake.m
//  New Image
//
//  Created by Thomas Denney on 26/08/2013
//  Copyright 2013 Thomas Denney
//  This code was generated by Opacity Express. You may use or modify it in any way.
//

#import "Cake.h"

const CGFloat kMyViewWidth = 1024.0f;
const CGFloat kMyViewHeight = 1024.0f;

@implementation MyView


- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        [self setOpaque:NO];
    }
    return self;
}

- (id)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];
    if (self) {
        [self setOpaque:NO];
    }
    return self;
}

- (CGSize)sizeThatFits:(CGSize)size
{
    return CGSizeMake(kMyViewWidth, kMyViewHeight);
}

- (void)drawRect:(CGRect)dirtyRect
{
    CGRect imageBounds = CGRectMake(0.0f, 0.0f, kMyViewWidth, kMyViewHeight);
    CGRect bounds = [self bounds];
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGFloat alignStroke;
    CGFloat resolution;
    CGMutablePathRef path;
    CGPoint point;
    CGGradientRef gradient;
    NSMutableArray *colors;
    UIColor *color;
    CGColorSpaceRef space = CGColorSpaceCreateDeviceRGB();
    CGPoint point2;
    CGAffineTransform transform;
    CGMutablePathRef tempPath;
    CGRect pathBounds;
    CGPoint controlPoint1;
    CGPoint controlPoint2;
    CGRect drawRect;
    CGFloat locations[2];
    resolution = 0.5f * (bounds.size.width / imageBounds.size.width + bounds.size.height / imageBounds.size.height);
    
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, bounds.origin.x, bounds.origin.y);
    CGContextScaleCTM(context, (bounds.size.width / imageBounds.size.width), (bounds.size.height / imageBounds.size.height));
    
    // Cake
    
    // Cake
    
    // Cake body
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    point = CGPointMake(146.6f, 433.25f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathMoveToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(146.6f, 767.15f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(512.0f, 867.95f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(877.4f, 767.15f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(877.4f, 433.25f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(146.6f, 433.25f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    CGPathCloseSubpath(path);
    colors = [NSMutableArray arrayWithCapacity:2];
    color = [UIColor colorWithRed:0.689f green:0.38f blue:0.059f alpha:1.0f];
    [colors addObject:(id)[color CGColor]];
    locations[0] = 0.0f;
    color = [UIColor colorWithRed:0.994f green:0.71f blue:0.07f alpha:1.0f];
    [colors addObject:(id)[color CGColor]];
    locations[1] = 1.0f;
    gradient = CGGradientCreateWithColors(space, (CFArrayRef)colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    transform = CGAffineTransformMakeRotation(0.262f);
    tempPath = CGPathCreateMutable();
    CGPathAddPath(tempPath, &transform, path);
    pathBounds = CGPathGetPathBoundingBox(tempPath);
    point = pathBounds.origin;
    point2 = CGPointMake(CGRectGetMaxX(pathBounds), CGRectGetMinY(pathBounds));
    transform = CGAffineTransformInvert(transform);
    point = CGPointApplyAffineTransform(point, transform);
    point2 = CGPointApplyAffineTransform(point2, transform);
    CGPathRelease(tempPath);
    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    // Cake base
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    point = CGPointMake(146.6f, 716.75f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathMoveToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(146.6f, 767.15f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(512.0f, 905.75f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(146.6f, 767.15f);
    controlPoint2 = CGPointMake(146.6f, 905.75f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(877.4f, 767.15f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(877.4f, 905.75f);
    controlPoint2 = CGPointMake(877.4f, 767.15f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(877.4f, 716.75f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(512.0f, 811.25f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(877.4f, 716.75f);
    controlPoint2 = CGPointMake(827.0f, 811.25f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(146.6f, 716.75f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(197.0f, 811.25f);
    controlPoint2 = CGPointMake(146.6f, 716.75f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    CGPathCloseSubpath(path);
    colors = [NSMutableArray arrayWithCapacity:2];
    color = [UIColor colorWithRed:0.68f green:0.284f blue:0.055f alpha:1.0f];
    [colors addObject:(id)[color CGColor]];
    locations[0] = 0.0f;
    color = [UIColor colorWithRed:0.953f green:0.612f blue:0.071f alpha:1.0f];
    [colors addObject:(id)[color CGColor]];
    locations[1] = 1.0f;
    gradient = CGGradientCreateWithColors(space, (CFArrayRef)colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    transform = CGAffineTransformMakeRotation(0.262f);
    tempPath = CGPathCreateMutable();
    CGPathAddPath(tempPath, &transform, path);
    pathBounds = CGPathGetPathBoundingBox(tempPath);
    point = pathBounds.origin;
    point2 = CGPointMake(CGRectGetMaxX(pathBounds), CGRectGetMinY(pathBounds));
    transform = CGAffineTransformInvert(transform);
    point = CGPointApplyAffineTransform(point, transform);
    point2 = CGPointApplyAffineTransform(point2, transform);
    CGPathRelease(tempPath);
    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    // Icing on body
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    point = CGPointMake(146.6f, 360.8f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathMoveToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(146.6f, 464.75f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(146.6f, 360.8f);
    controlPoint2 = CGPointMake(134.0f, 452.15f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(173.375f, 472.625f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(159.2f, 477.35f);
    controlPoint2 = CGPointMake(148.175f, 456.875f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(286.775f, 671.075f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(198.575f, 488.375f);
    controlPoint2 = CGPointMake(248.975f, 649.025f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(387.575f, 702.575f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(324.575f, 693.125f);
    controlPoint2 = CGPointMake(368.675f, 686.825f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(452.15f, 782.9f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(406.475f, 718.325f);
    controlPoint2 = CGPointMake(408.05f, 779.75f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(534.05f, 694.7f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(496.25f, 786.05f);
    controlPoint2 = CGPointMake(485.225f, 702.575f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(626.975f, 749.825f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(582.875f, 686.825f);
    controlPoint2 = CGPointMake(593.9f, 754.55f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(715.175f, 592.325f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(660.05f, 745.1f);
    controlPoint2 = CGPointMake(644.3f, 625.4f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(787.625f, 604.925f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(786.05f, 559.25f);
    controlPoint2 = CGPointMake(789.2f, 600.2f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(814.4f, 704.15f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(786.05f, 609.65f);
    controlPoint2 = CGPointMake(781.325f, 702.575f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(839.6f, 593.9f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(847.475f, 705.725f);
    controlPoint2 = CGPointMake(830.15f, 628.55f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(877.4f, 524.6f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(849.05f, 559.25f);
    controlPoint2 = CGPointMake(852.2f, 578.15f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(877.4f, 354.5f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(902.6f, 471.05f);
    controlPoint2 = CGPointMake(877.4f, 354.5f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(146.6f, 360.8f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    CGPathCloseSubpath(path);
    colors = [NSMutableArray arrayWithCapacity:2];
    color = [UIColor colorWithRed:0.126f green:0.059f blue:0.014f alpha:1.0f];
    [colors addObject:(id)[color CGColor]];
    locations[0] = 0.0f;
    color = [UIColor colorWithRed:0.243f green:0.103f blue:0.008f alpha:1.0f];
    [colors addObject:(id)[color CGColor]];
    locations[1] = 0.567f;
    gradient = CGGradientCreateWithColors(space, (CFArrayRef)colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    point = CGPointMake(514.389f, 782.987f);
    point2 = CGPointMake(514.389f, 354.5f);
    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    // Icing on top
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    drawRect = CGRectMake(146.6f, 228.5f, 730.8f, 283.5f);
    drawRect.origin.x = (roundf(resolution * drawRect.origin.x + alignStroke) - alignStroke) / resolution;
    drawRect.origin.y = (roundf(resolution * drawRect.origin.y + alignStroke) - alignStroke) / resolution;
    drawRect.size.width = roundf(resolution * drawRect.size.width) / resolution;
    drawRect.size.height = roundf(resolution * drawRect.size.height) / resolution;
    CGPathAddEllipseInRect(path, NULL, drawRect);
    colors = [NSMutableArray arrayWithCapacity:2];
    color = [UIColor colorWithRed:0.243f green:0.103f blue:0.008f alpha:1.0f];
    [colors addObject:(id)[color CGColor]];
    locations[0] = 0.632f;
    color = [UIColor colorWithRed:0.516f green:0.198f blue:0.016f alpha:1.0f];
    [colors addObject:(id)[color CGColor]];
    locations[1] = 1.0f;
    gradient = CGGradientCreateWithColors(space, (CFArrayRef)colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    point = CGPointMake(512.0f, 512.0f);
    point2 = CGPointMake(512.0f, 228.5f);
    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    // Top glow
    CGContextSetAlpha(context, 0.5f);
    CGContextBeginTransparencyLayer(context, NULL);
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    drawRect = CGRectMake(146.6f, 228.5f, 730.8f, 283.5f);
    drawRect.origin.x = (roundf(resolution * drawRect.origin.x + alignStroke) - alignStroke) / resolution;
    drawRect.origin.y = (roundf(resolution * drawRect.origin.y + alignStroke) - alignStroke) / resolution;
    drawRect.size.width = roundf(resolution * drawRect.size.width) / resolution;
    drawRect.size.height = roundf(resolution * drawRect.size.height) / resolution;
    CGPathAddEllipseInRect(path, NULL, drawRect);
    colors = [NSMutableArray arrayWithCapacity:2];
    color = [UIColor colorWithRed:1.0f green:1.0f blue:1.0f alpha:0.4f];
    [colors addObject:(id)[color CGColor]];
    locations[0] = 1.0f;
    color = [UIColor colorWithRed:1.0f green:1.0f blue:1.0f alpha:0.1f];
    [colors addObject:(id)[color CGColor]];
    locations[1] = 0.0f;
    gradient = CGGradientCreateWithColors(space, (CFArrayRef)colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    pathBounds = CGPathGetPathBoundingBox(path);
    transform = CGAffineTransformMakeTranslation(CGRectGetMidX(pathBounds), CGRectGetMidY(pathBounds));
    transform = CGAffineTransformScale(transform, 0.5f * pathBounds.size.width, 0.5f * pathBounds.size.height);
    CGContextConcatCTM(context, transform);
    CGContextDrawRadialGradient(context, gradient, CGPointZero, 1.0f, CGPointMake(0.0f, 0.0f), 0.0f, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    CGContextEndTransparencyLayer(context);
    
    CGContextRestoreGState(context);
    CGColorSpaceRelease(space);
}

@end
