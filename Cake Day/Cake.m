//
//  Cake.m
//  New Image
//
//  Created by Thomas Denney on 26/08/2013
//  Copyright 2013 Thomas Denney
//  This code was generated by Opacity Express. You may use or modify it in any way.
//

#include "Cake.h"

#include <math.h>

const CGFloat kCakeDrawingFunctionWidth = 280.0f;
const CGFloat kCakeDrawingFunctionHeight = 280.0f;

void CakeDrawingFunction(CGContextRef context, CGRect bounds)
{
    CGRect imageBounds = CGRectMake(0.0f, 0.0f, kCakeDrawingFunctionWidth, kCakeDrawingFunctionHeight);
    CGFloat alignStroke;
    CGFloat resolution;
    CGMutablePathRef path;
    CGRect drawRect;
    CGGradientRef gradient;
    CFMutableArrayRef colors;
    CGColorRef color;
    CGColorSpaceRef space = CGColorSpaceCreateDeviceRGB();
    CGPoint point;
    CGPoint point2;
    CGAffineTransform transform;
    CGMutablePathRef tempPath;
    CGRect pathBounds;
    CGPoint controlPoint1;
    CGPoint controlPoint2;
//    CGFloat stroke; Unused variable
    CGFloat components[4];
    CGFloat locations[2];
    
    transform = CGContextGetUserSpaceToDeviceSpaceTransform(context);
    resolution = sqrtf(fabsf(transform.a * transform.d - transform.b * transform.c)) * 0.5f * (bounds.size.width / imageBounds.size.width + bounds.size.height / imageBounds.size.height);
    
    CGContextSaveGState(context);
    CGContextClipToRect(context, bounds);
    CGContextTranslateCTM(context, bounds.origin.x, bounds.origin.y);
    CGContextScaleCTM(context, (bounds.size.width / imageBounds.size.width), (bounds.size.height / imageBounds.size.height));
    
    // Background
    
    // Background layer
    
//    alignStroke = 0.0f;
//    path = CGPathCreateMutable();
//    drawRect = CGRectMake(0.0f, 0.0f, 280.0f, 280.0f);
//    drawRect.origin.x = (roundf(resolution * drawRect.origin.x + alignStroke) - alignStroke) / resolution;
//    drawRect.origin.y = (roundf(resolution * drawRect.origin.y + alignStroke) - alignStroke) / resolution;
//    drawRect.size.width = roundf(resolution * drawRect.size.width) / resolution;
//    drawRect.size.height = roundf(resolution * drawRect.size.height) / resolution;
//    CGPathAddRect(path, NULL, drawRect);
//    colors = CFArrayCreateMutable(NULL, 2, &kCFTypeArrayCallBacks);
//    components[0] = 0.061f;
//    components[1] = 0.511f;
//    components[2] = 0.998f;
//    components[3] = 1.0f;
//    color = CGColorCreate(space, components);
//    CFArrayAppendValue(colors, color);
//    CGColorRelease(color);
//    locations[0] = 0.0f;
//    components[0] = 0.136f;
//    components[1] = 0.348f;
//    components[2] = 0.529f;
//    components[3] = 1.0f;
//    color = CGColorCreate(space, components);
//    CFArrayAppendValue(colors, color);
//    CGColorRelease(color);
//    locations[1] = 1.0f;
//    gradient = CGGradientCreateWithColors(space, colors, locations);
//    CGContextAddPath(context, path);
//    CGContextSaveGState(context);
//    CGContextEOClip(context);
//    transform = CGAffineTransformMakeRotation(1.571f);
//    tempPath = CGPathCreateMutable();
//    CGPathAddPath(tempPath, &transform, path);
//    pathBounds = CGPathGetPathBoundingBox(tempPath);
//    point = pathBounds.origin;
//    point2 = CGPointMake(CGRectGetMaxX(pathBounds), CGRectGetMinY(pathBounds));
//    transform = CGAffineTransformInvert(transform);
//    point = CGPointApplyAffineTransform(point, transform);
//    point2 = CGPointApplyAffineTransform(point2, transform);
//    CGPathRelease(tempPath);
//    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
//    CGContextRestoreGState(context);
//    CFRelease(colors);
//    CGGradientRelease(gradient);
//    CGPathRelease(path);
    
    // Cake
    
    // Setup for Shadow Effect
//    components[0] = 0.0f;
//    components[1] = 0.0f;
//    components[2] = 0.0f;
//    components[3] = 0.5f;
//color = CGColorCreate(space, components);
//    CGContextSaveGState(context);
//    CGContextSetShadowWithColor(context, CGSizeMake(0.0f * resolution, 0.0f * resolution), 20.0f * resolution, color);
//    CGColorRelease(color);
//    CGContextBeginTransparencyLayer(context, NULL);
//    
    // Cake body
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    point = CGPointMake(35.6f, 117.5f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathMoveToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(35.6f, 212.9f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(140.0f, 241.7f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(244.4f, 212.9f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(244.4f, 117.5f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(35.6f, 117.5f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    CGPathCloseSubpath(path);
    colors = CFArrayCreateMutable(NULL, 2, &kCFTypeArrayCallBacks);
    components[0] = 0.689f;
    components[1] = 0.38f;
    components[2] = 0.059f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[0] = 0.0f;
    components[0] = 0.994f;
    components[1] = 0.71f;
    components[2] = 0.07f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[1] = 1.0f;
    gradient = CGGradientCreateWithColors(space, colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    transform = CGAffineTransformMakeRotation(0.262f);
    tempPath = CGPathCreateMutable();
    CGPathAddPath(tempPath, &transform, path);
    pathBounds = CGPathGetPathBoundingBox(tempPath);
    point = pathBounds.origin;
    point2 = CGPointMake(CGRectGetMaxX(pathBounds), CGRectGetMinY(pathBounds));
    transform = CGAffineTransformInvert(transform);
    point = CGPointApplyAffineTransform(point, transform);
    point2 = CGPointApplyAffineTransform(point2, transform);
    CGPathRelease(tempPath);
    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CFRelease(colors);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    // Cake base
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    point = CGPointMake(35.6f, 198.5f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathMoveToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(35.6f, 212.9f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(140.0f, 252.5f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(35.6f, 212.9f);
    controlPoint2 = CGPointMake(35.6f, 252.5f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(244.4f, 212.9f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(244.4f, 252.5f);
    controlPoint2 = CGPointMake(244.4f, 212.9f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(244.4f, 198.5f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(140.0f, 225.5f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(244.4f, 198.5f);
    controlPoint2 = CGPointMake(230.0f, 225.5f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(35.6f, 198.5f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(50.0f, 225.5f);
    controlPoint2 = CGPointMake(35.6f, 198.5f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    CGPathCloseSubpath(path);
    colors = CFArrayCreateMutable(NULL, 2, &kCFTypeArrayCallBacks);
    components[0] = 0.68f;
    components[1] = 0.284f;
    components[2] = 0.055f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[0] = 0.0f;
    components[0] = 0.953f;
    components[1] = 0.612f;
    components[2] = 0.071f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[1] = 1.0f;
    gradient = CGGradientCreateWithColors(space, colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    transform = CGAffineTransformMakeRotation(0.262f);
    tempPath = CGPathCreateMutable();
    CGPathAddPath(tempPath, &transform, path);
    pathBounds = CGPathGetPathBoundingBox(tempPath);
    point = pathBounds.origin;
    point2 = CGPointMake(CGRectGetMaxX(pathBounds), CGRectGetMinY(pathBounds));
    transform = CGAffineTransformInvert(transform);
    point = CGPointApplyAffineTransform(point, transform);
    point2 = CGPointApplyAffineTransform(point2, transform);
    CGPathRelease(tempPath);
    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CFRelease(colors);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    // Icing on body
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    point = CGPointMake(35.6f, 96.8f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathMoveToPoint(path, NULL, point.x, point.y);
    point = CGPointMake(35.6f, 126.5f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(35.6f, 96.8f);
    controlPoint2 = CGPointMake(32.0f, 122.9f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(43.25f, 128.75f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(39.2f, 130.1f);
    controlPoint2 = CGPointMake(36.05f, 124.25f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(75.65f, 185.45f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(50.45f, 133.25f);
    controlPoint2 = CGPointMake(64.85f, 179.15f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(104.45f, 194.45f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(86.45f, 191.75f);
    controlPoint2 = CGPointMake(99.05f, 189.95f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(122.9f, 217.4f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(109.85f, 198.95f);
    controlPoint2 = CGPointMake(110.3f, 216.5f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(146.3f, 192.2f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(135.5f, 218.3f);
    controlPoint2 = CGPointMake(132.35f, 194.45f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(172.85f, 207.95f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(160.25f, 189.95f);
    controlPoint2 = CGPointMake(163.4f, 209.3f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(198.05f, 162.95f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(182.3f, 206.6f);
    controlPoint2 = CGPointMake(177.8f, 172.4f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(218.75f, 166.55f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(218.3f, 153.5f);
    controlPoint2 = CGPointMake(219.2f, 165.2f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(226.4f, 194.9f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(218.3f, 167.9f);
    controlPoint2 = CGPointMake(216.95f, 194.45f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(233.6f, 163.4f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(235.85f, 195.35f);
    controlPoint2 = CGPointMake(230.9f, 173.3f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(244.4f, 143.6f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(236.3f, 153.5f);
    controlPoint2 = CGPointMake(237.2f, 158.9f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(244.4f, 95.0f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    controlPoint1 = CGPointMake(251.6f, 128.3f);
    controlPoint2 = CGPointMake(244.4f, 95.0f);
    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
    point = CGPointMake(35.6f, 96.8f);
    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
    CGPathAddLineToPoint(path, NULL, point.x, point.y);
    CGPathCloseSubpath(path);
    colors = CFArrayCreateMutable(NULL, 2, &kCFTypeArrayCallBacks);
    components[0] = 0.126f;
    components[1] = 0.059f;
    components[2] = 0.014f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[0] = 0.0f;
    components[0] = 0.243f;
    components[1] = 0.103f;
    components[2] = 0.008f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[1] = 0.567f;
    gradient = CGGradientCreateWithColors(space, colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    point = CGPointMake(140.683f, 217.425f);
    point2 = CGPointMake(140.683f, 95.0f);
    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CFRelease(colors);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    // Icing on top
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    drawRect = CGRectMake(35.6f, 59.0f, 208.8f, 81.0f);
    drawRect.origin.x = (roundf(resolution * drawRect.origin.x + alignStroke) - alignStroke) / resolution;
    drawRect.origin.y = (roundf(resolution * drawRect.origin.y + alignStroke) - alignStroke) / resolution;
    drawRect.size.width = roundf(resolution * drawRect.size.width) / resolution;
    drawRect.size.height = roundf(resolution * drawRect.size.height) / resolution;
    CGPathAddEllipseInRect(path, NULL, drawRect);
    colors = CFArrayCreateMutable(NULL, 2, &kCFTypeArrayCallBacks);
    components[0] = 0.243f;
    components[1] = 0.103f;
    components[2] = 0.008f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[0] = 0.632f;
    components[0] = 0.516f;
    components[1] = 0.198f;
    components[2] = 0.016f;
    components[3] = 1.0f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[1] = 1.0f;
    gradient = CGGradientCreateWithColors(space, colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    point = CGPointMake(140.0f, 140.0f);
    point2 = CGPointMake(140.0f, 59.0f);
    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CFRelease(colors);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    // Top glow
    CGContextSetAlpha(context, 0.5f);
    CGContextBeginTransparencyLayer(context, NULL);
    
    alignStroke = 0.0f;
    path = CGPathCreateMutable();
    drawRect = CGRectMake(35.6f, 59.0f, 208.8f, 81.0f);
    drawRect.origin.x = (roundf(resolution * drawRect.origin.x + alignStroke) - alignStroke) / resolution;
    drawRect.origin.y = (roundf(resolution * drawRect.origin.y + alignStroke) - alignStroke) / resolution;
    drawRect.size.width = roundf(resolution * drawRect.size.width) / resolution;
    drawRect.size.height = roundf(resolution * drawRect.size.height) / resolution;
    CGPathAddEllipseInRect(path, NULL, drawRect);
    colors = CFArrayCreateMutable(NULL, 2, &kCFTypeArrayCallBacks);
    components[0] = 1.0f;
    components[1] = 1.0f;
    components[2] = 1.0f;
    components[3] = 0.4f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[0] = 1.0f;
    components[0] = 1.0f;
    components[1] = 1.0f;
    components[2] = 1.0f;
    components[3] = 0.1f;
    color = CGColorCreate(space, components);
    CFArrayAppendValue(colors, color);
    CGColorRelease(color);
    locations[1] = 0.0f;
    gradient = CGGradientCreateWithColors(space, colors, locations);
    CGContextAddPath(context, path);
    CGContextSaveGState(context);
    CGContextEOClip(context);
    pathBounds = CGPathGetPathBoundingBox(path);
    transform = CGAffineTransformMakeTranslation(CGRectGetMidX(pathBounds), CGRectGetMidY(pathBounds));
    transform = CGAffineTransformScale(transform, 0.5f * pathBounds.size.width, 0.5f * pathBounds.size.height);
    CGContextConcatCTM(context, transform);
    CGContextDrawRadialGradient(context, gradient, CGPointZero, 1.0f, CGPointMake(0.0f, 0.0f), 0.0f, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
    CGContextRestoreGState(context);
    CFRelease(colors);
    CGGradientRelease(gradient);
    CGPathRelease(path);
    
    CGContextEndTransparencyLayer(context);
    
    // Candle
//    CGContextSetAlpha(context, 1.0f);
//    
//    stroke = 1.0f;
//    stroke *= resolution;
//    if (stroke < 1.0f) {
//        stroke = ceilf(stroke);
//    } else {
//        stroke = roundf(stroke);
//    }
//    stroke /= resolution;
//    alignStroke = fmodf(0.5f * stroke * resolution, 1.0f);
//    path = CGPathCreateMutable();
//    point = CGPointMake(131.0f, 113.0f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    CGPathMoveToPoint(path, NULL, point.x, point.y);
//    point = CGPointMake(140.0f, 117.5f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(131.0f, 113.0f);
//    controlPoint2 = CGPointMake(131.0f, 117.5f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    point = CGPointMake(149.0f, 113.0f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(149.0f, 117.5f);
//    controlPoint2 = CGPointMake(149.0f, 113.0f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    point = CGPointMake(149.0f, 68.0f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(149.0f, 113.0f);
//    controlPoint2 = CGPointMake(144.5f, 72.5f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    point = CGPointMake(139.55f, 68.0f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(153.5f, 63.5f);
//    controlPoint2 = CGPointMake(148.55f, 68.0f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    point = CGPointMake(131.0f, 68.0f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(130.55f, 68.0f);
//    controlPoint2 = CGPointMake(126.5f, 63.5f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    point = CGPointMake(131.0f, 113.0f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(135.5f, 72.5f);
//    controlPoint2 = CGPointMake(131.0f, 113.0f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    CGPathCloseSubpath(path);
//    colors = CFArrayCreateMutable(NULL, 2, &kCFTypeArrayCallBacks);
//    components[0] = 0.6f;
//    components[1] = 0.6f;
//    components[2] = 0.6f;
//    components[3] = 1.0f;
//    color = CGColorCreate(space, components);
//    CFArrayAppendValue(colors, color);
//    CGColorRelease(color);
//    locations[0] = 0.0f;
//    components[0] = 1.0f;
//    components[1] = 1.0f;
//    components[2] = 1.0f;
//    components[3] = 1.0f;
//    color = CGColorCreate(space, components);
//    CFArrayAppendValue(colors, color);
//    CGColorRelease(color);
//    locations[1] = 1.0f;
//    gradient = CGGradientCreateWithColors(space, colors, locations);
//    CGContextAddPath(context, path);
//    CGContextSaveGState(context);
//    CGContextEOClip(context);
//    transform = CGAffineTransformMakeRotation(1.571f);
//    tempPath = CGPathCreateMutable();
//    CGPathAddPath(tempPath, &transform, path);
//    pathBounds = CGPathGetPathBoundingBox(tempPath);
//    point = pathBounds.origin;
//    point2 = CGPointMake(CGRectGetMaxX(pathBounds), CGRectGetMinY(pathBounds));
//    transform = CGAffineTransformInvert(transform);
//    point = CGPointApplyAffineTransform(point, transform);
//    point2 = CGPointApplyAffineTransform(point2, transform);
//    CGPathRelease(tempPath);
//    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
//    CGContextRestoreGState(context);
//    CFRelease(colors);
//    CGGradientRelease(gradient);
//    components[0] = 0.0f;
//    components[1] = 0.0f;
//    components[2] = 0.0f;
//    components[3] = 1.0f;
//    color = CGColorCreate(space, components);
//    CGContextSetStrokeColorWithColor(context, color);
//    CGColorRelease(color);
//    CGContextSetLineWidth(context, stroke);
//    CGContextSetLineCap(context, kCGLineCapSquare);
//    CGContextAddPath(context, path);
//    CGContextStrokePath(context);
//    CGPathRelease(path);
//    
//    stroke = 1.0f;
//    stroke *= resolution;
//    if (stroke < 1.0f) {
//        stroke = ceilf(stroke);
//    } else {
//        stroke = roundf(stroke);
//    }
//    stroke /= resolution;
//    alignStroke = fmodf(0.5f * stroke * resolution, 1.0f);
//    path = CGPathCreateMutable();
//    point = CGPointMake(139.1f, 65.3f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    CGPathMoveToPoint(path, NULL, point.x, point.y);
//    point = CGPointMake(130.1f, 56.3f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(134.6f, 65.3f);
//    controlPoint2 = CGPointMake(130.1f, 60.8f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    point = CGPointMake(139.1f, 33.8f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(130.1f, 51.8f);
//    controlPoint2 = CGPointMake(139.1f, 33.8f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    point = CGPointMake(148.1f, 56.3f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(139.1f, 33.8f);
//    controlPoint2 = CGPointMake(148.1f, 47.3f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    point = CGPointMake(139.1f, 65.3f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(148.1f, 65.3f);
//    controlPoint2 = CGPointMake(143.6f, 65.3f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    CGPathCloseSubpath(path);
//    colors = CFArrayCreateMutable(NULL, 2, &kCFTypeArrayCallBacks);
//    components[0] = 0.595f;
//    components[1] = 0.375f;
//    components[2] = 0.021f;
//    components[3] = 1.0f;
//    color = CGColorCreate(space, components);
//    CFArrayAppendValue(colors, color);
//    CGColorRelease(color);
//    locations[0] = 0.0f;
//    components[0] = 0.926f;
//    components[1] = 0.576f;
//    components[2] = 0.032f;
//    components[3] = 1.0f;
//    color = CGColorCreate(space, components);
//    CFArrayAppendValue(colors, color);
//    CGColorRelease(color);
//    locations[1] = 1.0f;
//    gradient = CGGradientCreateWithColors(space, colors, locations);
//    CGContextAddPath(context, path);
//    CGContextSaveGState(context);
//    CGContextEOClip(context);
//    transform = CGAffineTransformMakeRotation(1.571f);
//    tempPath = CGPathCreateMutable();
//    CGPathAddPath(tempPath, &transform, path);
//    pathBounds = CGPathGetPathBoundingBox(tempPath);
//    point = pathBounds.origin;
//    point2 = CGPointMake(CGRectGetMaxX(pathBounds), CGRectGetMinY(pathBounds));
//    transform = CGAffineTransformInvert(transform);
//    point = CGPointApplyAffineTransform(point, transform);
//    point2 = CGPointApplyAffineTransform(point2, transform);
//    CGPathRelease(tempPath);
//    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
//    CGContextRestoreGState(context);
//    CFRelease(colors);
//    CGGradientRelease(gradient);
//    components[0] = 0.0f;
//    components[1] = 0.0f;
//    components[2] = 0.0f;
//    components[3] = 1.0f;
//    color = CGColorCreate(space, components);
//    CGContextSetStrokeColorWithColor(context, color);
//    CGColorRelease(color);
//    CGContextAddPath(context, path);
//    CGContextStrokePath(context);
//    CGPathRelease(path);
//    
//    alignStroke = 0.0f;
//    path = CGPathCreateMutable();
//    point = CGPointMake(139.1f, 65.3f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    CGPathMoveToPoint(path, NULL, point.x, point.y);
//    point = CGPointMake(132.8f, 59.0f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(135.95f, 65.3f);
//    controlPoint2 = CGPointMake(132.8f, 62.15f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    point = CGPointMake(139.1f, 43.25f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(132.8f, 55.85f);
//    controlPoint2 = CGPointMake(139.1f, 43.25f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    point = CGPointMake(145.4f, 59.0f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(139.1f, 43.25f);
//    controlPoint2 = CGPointMake(145.4f, 52.7f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    point = CGPointMake(139.1f, 65.3f);
//    point.x = (roundf(resolution * point.x + alignStroke) - alignStroke) / resolution;
//    point.y = (roundf(resolution * point.y + alignStroke) - alignStroke) / resolution;
//    controlPoint1 = CGPointMake(145.4f, 65.3f);
//    controlPoint2 = CGPointMake(142.25f, 65.3f);
//    CGPathAddCurveToPoint(path, NULL, controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, point.x, point.y);
//    CGPathCloseSubpath(path);
//    colors = CFArrayCreateMutable(NULL, 2, &kCFTypeArrayCallBacks);
//    components[0] = 0.586f;
//    components[1] = 0.487f;
//    components[2] = 0.05f;
//    components[3] = 1.0f;
//    color = CGColorCreate(space, components);
//    CFArrayAppendValue(colors, color);
//    CGColorRelease(color);
//    locations[0] = 0.0f;
//    components[0] = 0.995f;
//    components[1] = 0.76f;
//    components[2] = 0.037f;
//    components[3] = 1.0f;
//    color = CGColorCreate(space, components);
//    CFArrayAppendValue(colors, color);
//    CGColorRelease(color);
//    locations[1] = 1.0f;
//    gradient = CGGradientCreateWithColors(space, colors, locations);
//    CGContextAddPath(context, path);
//    CGContextSaveGState(context);
//    CGContextEOClip(context);
//    transform = CGAffineTransformMakeRotation(1.571f);
//    tempPath = CGPathCreateMutable();
//    CGPathAddPath(tempPath, &transform, path);
//    pathBounds = CGPathGetPathBoundingBox(tempPath);
//    point = pathBounds.origin;
//    point2 = CGPointMake(CGRectGetMaxX(pathBounds), CGRectGetMinY(pathBounds));
//    transform = CGAffineTransformInvert(transform);
//    point = CGPointApplyAffineTransform(point, transform);
//    point2 = CGPointApplyAffineTransform(point2, transform);
//    CGPathRelease(tempPath);
//    CGContextDrawLinearGradient(context, gradient, point, point2, (kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation));
//    CGContextRestoreGState(context);
//    CFRelease(colors);
//    CGGradientRelease(gradient);
//    CGPathRelease(path);
    
    // Shadow Effect
//    CGContextEndTransparencyLayer(context);
//    CGContextRestoreGState(context);
    
    CGContextRestoreGState(context);
    CGColorSpaceRelease(space);
}
